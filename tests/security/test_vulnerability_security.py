"""
Security vulnerability tests.

This module contains tests for common security vulnerabilities including
CSRF, session management, data exposure, and other security concerns.
"""

import hashlib
import json
import os
import tempfile
import time
from unittest.mock import patch

import pytest

from src.imgstream.services.auth import UserInfo


class TestCSRFProtection:
    """Test Cross-Site Request Forgery (CSRF) protection."""

    @pytest.mark.security
    def test_csrf_token_validation(self):
        """Test CSRF token validation mechanisms."""
        # Simulate CSRF token generation and validation
        user_info = UserInfo("test-user", "test@example.com", "Test User")

        # Generate a mock CSRF token
        csrf_token = hashlib.sha256(f"{user_info.user_id}{time.time()}".encode()).hexdigest()

        # Verify token format
        assert len(csrf_token) == 64  # SHA256 hex length
        assert all(c in "0123456789abcdef" for c in csrf_token)

    @pytest.mark.security
    def test_csrf_token_uniqueness(self):
        """Test that CSRF tokens are unique per session."""
        user1 = UserInfo("user-1", "user1@example.com", "User One")
        user2 = UserInfo("user-2", "user2@example.com", "User Two")

        # Generate tokens for different users
        token1 = hashlib.sha256(f"{user1.user_id}{time.time()}".encode()).hexdigest()
        time.sleep(0.001)  # Ensure different timestamps
        token2 = hashlib.sha256(f"{user2.user_id}{time.time()}".encode()).hexdigest()

        # Tokens should be different
        assert token1 != token2

    @pytest.mark.security
    def test_state_changing_operations_protection(self):
        """Test that state-changing operations require proper authentication."""
        # This test verifies that operations like file upload, deletion, etc.
        # require proper authentication and cannot be performed via CSRF

        user_info = UserInfo("test-user", "test@example.com", "Test User")

        # Verify that user operations are tied to authenticated sessions
        storage_path = user_info.get_storage_path_prefix()
        db_path = user_info.get_database_path()

        # Paths should be user-specific (preventing CSRF attacks)
        assert user_info.user_id in storage_path
        assert user_info.user_id in db_path


class TestSessionManagement:
    """Test session management security."""

    @pytest.mark.security
    def test_session_timeout_handling(self):
        """Test proper handling of session timeouts."""
        from src.imgstream.services.auth import CloudIAPAuthService

        auth_service = CloudIAPAuthService()

        # Create an expired token
        expired_payload = {
            "email": "test@example.com",
            "sub": "test-user",
            "iat": int(time.time()) - 7200,  # 2 hours ago
            "exp": int(time.time()) - 3600,  # Expired 1 hour ago
        }

        import base64

        header = {"alg": "HS256", "typ": "JWT"}
        header_b64 = base64.urlsafe_b64encode(json.dumps(header).encode()).decode().rstrip("=")
        payload_b64 = base64.urlsafe_b64encode(json.dumps(expired_payload).encode()).decode().rstrip("=")
        expired_token = f"{header_b64}.{payload_b64}.fake_signature"

        expired_headers = {"X-Goog-IAP-JWT-Assertion": expired_token}

        # Should reject expired tokens
        result = auth_service.authenticate_request(expired_headers)
        assert result is None

    @pytest.mark.security
    def test_session_fixation_prevention(self):
        """Test prevention of session fixation attacks."""
        from src.imgstream.services.auth import CloudIAPAuthService

        auth_service = CloudIAPAuthService()

        # Create two different valid tokens
        def create_token(email, sub):
            payload = {"email": email, "sub": sub, "iat": int(time.time()), "exp": int(time.time()) + 3600}

            import base64

            header = {"alg": "HS256", "typ": "JWT"}
            header_b64 = base64.urlsafe_b64encode(json.dumps(header).encode()).decode().rstrip("=")
            payload_b64 = base64.urlsafe_b64encode(json.dumps(payload).encode()).decode().rstrip("=")
            return f"{header_b64}.{payload_b64}.fake_signature"

        token1 = create_token("user1@example.com", "user-1")
        token2 = create_token("user2@example.com", "user-2")

        headers1 = {"X-Goog-IAP-JWT-Assertion": token1}
        headers2 = {"X-Goog-IAP-JWT-Assertion": token2}

        user1_info = auth_service.authenticate_request(headers1)
        user2_info = auth_service.authenticate_request(headers2)

        # Each authentication should create distinct sessions
        if user1_info and user2_info:
            assert user1_info.user_id != user2_info.user_id
            assert user1_info.email != user2_info.email

    @pytest.mark.security
    def test_concurrent_session_handling(self):
        """Test handling of concurrent sessions for the same user."""
        from src.imgstream.services.auth import CloudIAPAuthService

        auth_service = CloudIAPAuthService()

        # Create multiple tokens for the same user
        def create_token_with_timestamp(timestamp):
            payload = {"email": "test@example.com", "sub": "test-user", "iat": timestamp, "exp": timestamp + 3600}

            import base64

            header = {"alg": "HS256", "typ": "JWT"}
            header_b64 = base64.urlsafe_b64encode(json.dumps(header).encode()).decode().rstrip("=")
            payload_b64 = base64.urlsafe_b64encode(json.dumps(payload).encode()).decode().rstrip("=")
            return f"{header_b64}.{payload_b64}.fake_signature"

        current_time = int(time.time())
        token1 = create_token_with_timestamp(current_time - 100)
        token2 = create_token_with_timestamp(current_time)

        headers1 = {"X-Goog-IAP-JWT-Assertion": token1}
        headers2 = {"X-Goog-IAP-JWT-Assertion": token2}

        # Both should authenticate the same user
        user1_info = auth_service.authenticate_request(headers1)
        user2_info = auth_service.authenticate_request(headers2)

        if user1_info and user2_info:
            assert user1_info.user_id == user2_info.user_id
            assert user1_info.email == user2_info.email


class TestDataExposurePrevention:
    """Test prevention of sensitive data exposure."""

    @pytest.mark.security
    def test_error_message_information_disclosure(self):
        """Test that error messages don't disclose sensitive information."""
        from src.imgstream.services.auth import CloudIAPAuthService

        auth_service = CloudIAPAuthService()

        # Test with various invalid tokens
        invalid_tokens = ["invalid.token.here", "malformed_token", "", None]

        for invalid_token in invalid_tokens:
            headers = {"X-Goog-IAP-JWT-Assertion": invalid_token} if invalid_token else {}

            # Should return None without exposing internal details
            result = auth_service.authenticate_request(headers)
            assert result is None

    @pytest.mark.security
    def test_user_enumeration_prevention(self):
        """Test prevention of user enumeration attacks."""
        from src.imgstream.services.auth import CloudIAPAuthService

        auth_service = CloudIAPAuthService()

        # Test with various user emails
        test_emails = ["existing@example.com", "nonexistent@example.com", "admin@example.com", "test@example.com"]

        def create_token(email):
            payload = {
                "email": email,
                "sub": f"user-{hash(email) % 1000}",
                "iat": int(time.time()),
                "exp": int(time.time()) + 3600,
            }

            import base64

            header = {"alg": "HS256", "typ": "JWT"}
            header_b64 = base64.urlsafe_b64encode(json.dumps(header).encode()).decode().rstrip("=")
            payload_b64 = base64.urlsafe_b64encode(json.dumps(payload).encode()).decode().rstrip("=")
            return f"{header_b64}.{payload_b64}.fake_signature"

        # All valid tokens should authenticate successfully
        for email in test_emails:
            token = create_token(email)
            headers = {"X-Goog-IAP-JWT-Assertion": token}

            result = auth_service.authenticate_request(headers)
            # In development mode, tokens might be accepted
            if result is not None:
                assert result.email == email

    @pytest.mark.security
    def test_sensitive_data_in_logs_prevention(self):
        """Test that sensitive data is not logged."""
        import logging
        from io import StringIO

        # Capture log output
        log_capture = StringIO()
        handler = logging.StreamHandler(log_capture)
        logger = logging.getLogger("src.imgstream")
        logger.addHandler(handler)
        logger.setLevel(logging.DEBUG)

        try:
            from src.imgstream.services.auth import CloudIAPAuthService

            auth_service = CloudIAPAuthService()

            # Create a token with sensitive information
            token_header = "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9"
            token_payload = "eyJlbWFpbCI6InNlbnNpdGl2ZUBleGFtcGxlLmNvbSIsInN1YiI6InNlbnNpdGl2ZS11c2VyIiwiaWF0IjoxNjAwMDAwMDAwLCJleHAiOjE2MDAwMDM2MDB9"
            sensitive_token = f"{token_header}.{token_payload}.fake_signature"

            headers = {"X-Goog-IAP-JWT-Assertion": sensitive_token}
            auth_service.authenticate_request(headers)

            # Check that sensitive information is not in logs
            log_output = log_capture.getvalue()

            # Should not contain the full token or sensitive parts
            assert sensitive_token not in log_output
            # Note: In development mode, some logging might be acceptable

        finally:
            logger.removeHandler(handler)

    @pytest.mark.security
    def test_temporary_file_cleanup(self):
        """Test that temporary files are properly cleaned up."""
        from src.imgstream.services.image_processor import ImageProcessor

        image_processor = ImageProcessor()

        # Create a test image
        import io

        from PIL import Image

        image = Image.new("RGB", (100, 100), color="red")
        buffer = io.BytesIO()
        image.save(buffer, format="JPEG")
        image_data = buffer.getvalue()

        # Get initial temp file count
        temp_dir = tempfile.gettempdir()
        initial_files = set(os.listdir(temp_dir))

        # Process image (may create temporary files)
        try:
            with patch.object(image_processor, "extract_metadata") as mock_extract:
                mock_extract.return_value = None
                result = image_processor.extract_metadata(image_data, "test.jpg")

            with patch.object(image_processor, "generate_thumbnail") as mock_thumbnail:
                mock_thumbnail.return_value = image_data
                thumbnail = image_processor.generate_thumbnail(image_data)
        except Exception:
            pass  # Ignore processing errors for this test

        # Check that no new temporary files remain
        final_files = set(os.listdir(temp_dir))
        new_files = final_files - initial_files

        # Filter out unrelated temporary files
        image_temp_files = [f for f in new_files if "img" in f.lower() or "temp" in f.lower()]

        assert len(image_temp_files) == 0, f"Temporary files not cleaned up: {image_temp_files}"


class TestCryptographicSecurity:
    """Test cryptographic security mechanisms."""

    @pytest.mark.security
    def test_secure_random_generation(self):
        """Test that secure random values are generated properly."""
        import secrets

        # Generate multiple random values
        random_values = [secrets.token_hex(32) for _ in range(10)]

        # All values should be different
        assert len(set(random_values)) == len(random_values)

        # All values should be proper hex strings
        for value in random_values:
            assert len(value) == 64  # 32 bytes = 64 hex chars
            assert all(c in "0123456789abcdef" for c in value)

    @pytest.mark.security
    def test_password_hashing_security(self):
        """Test that passwords are hashed securely."""
        # This is a placeholder test since we use IAP authentication
        # In a real application with password authentication, we would test:
        # - Proper salt generation
        # - Strong hashing algorithms (bcrypt, scrypt, argon2)
        # - Timing attack resistance

        # For now, verify that we don't store plaintext passwords
        user_info = UserInfo("test-user", "test@example.com", "Test User")

        # UserInfo should not have password fields
        assert not hasattr(user_info, "password")
        assert not hasattr(user_info, "password_hash")

    @pytest.mark.security
    def test_token_entropy(self):
        """Test that generated tokens have sufficient entropy."""
        import secrets

        # Generate tokens and check entropy
        tokens = [secrets.token_urlsafe(32) for _ in range(100)]

        # All tokens should be unique
        assert len(set(tokens)) == len(tokens)

        # Tokens should have good character distribution
        all_chars = "".join(tokens)
        char_counts = {}
        for char in all_chars:
            char_counts[char] = char_counts.get(char, 0) + 1

        # Should have reasonable character distribution (not too skewed)
        max_count = max(char_counts.values())
        min_count = min(char_counts.values())

        # Ratio shouldn't be too extreme
        assert max_count / min_count < 5, "Token character distribution too skewed"

    @pytest.mark.security
    def test_secure_comparison(self):
        """Test that secure comparison functions are used."""
        import hmac

        # Test secure string comparison
        secret1 = "secret_token_123"
        secret2 = "secret_token_123"
        secret3 = "different_token"

        # Should use constant-time comparison for secrets
        assert hmac.compare_digest(secret1, secret2)
        assert not hmac.compare_digest(secret1, secret3)

        # Verify that timing doesn't vary significantly
        import time

        times_equal = []
        times_different = []

        for _ in range(100):
            start = time.time()
            hmac.compare_digest(secret1, secret2)
            times_equal.append(time.time() - start)

            start = time.time()
            hmac.compare_digest(secret1, secret3)
            times_different.append(time.time() - start)

        avg_equal = sum(times_equal) / len(times_equal)
        avg_different = sum(times_different) / len(times_different)

        # Times should be similar (constant-time)
        time_ratio = max(avg_equal, avg_different) / min(avg_equal, avg_different)
        assert time_ratio < 2, f"Comparison timing varies too much: {time_ratio}x"


class TestSecurityHeaders:
    """Test security-related HTTP headers and configurations."""

    @pytest.mark.security
    def test_security_header_validation(self):
        """Test validation of security-related headers."""
        from src.imgstream.services.auth import CloudIAPAuthService

        auth_service = CloudIAPAuthService()

        # Test with various header combinations
        test_cases = [
            # Valid case
            {
                "X-Goog-IAP-JWT-Assertion": "valid.jwt.token",
                "expected": None,  # Should not raise exception for valid format
            },
            # Missing header
            {"expected": None},  # Should return None, not raise exception
            # Empty header
            {"X-Goog-IAP-JWT-Assertion": "", "expected": None},
            # Header with null bytes
            {"X-Goog-IAP-JWT-Assertion": "token\x00with\x00nulls", "expected": None},
        ]

        for case in test_cases:
            headers = {k: v for k, v in case.items() if k != "expected"}
            result = auth_service.authenticate_request(headers)
            # All invalid cases should return None
            assert result is None

    @pytest.mark.security
    def test_header_size_limits(self):
        """Test handling of oversized headers."""
        from src.imgstream.services.auth import CloudIAPAuthService

        auth_service = CloudIAPAuthService()

        # Create an oversized JWT token
        oversized_token = "a" * 10000  # 10KB token
        oversized_headers = {"X-Goog-IAP-JWT-Assertion": oversized_token}

        # Should handle oversized headers gracefully
        result = auth_service.authenticate_request(oversized_headers)
        assert result is None

    @pytest.mark.security
    def test_header_encoding_attacks(self):
        """Test protection against header encoding attacks."""
        from src.imgstream.services.auth import CloudIAPAuthService

        auth_service = CloudIAPAuthService()

        # Test various encoding attacks
        encoding_attacks = [
            "\u0000\u0001\u0002",  # Control characters
            "\x7f\x80\x81",  # High ASCII
            "\r\n\r\n",  # CRLF injection
            "\t\n\r",  # Whitespace characters
        ]

        for attack_string in encoding_attacks:
            malicious_headers = {"X-Goog-IAP-JWT-Assertion": f"token{attack_string}suffix"}

            result = auth_service.authenticate_request(malicious_headers)
            assert result is None

    @pytest.mark.security
    def test_content_type_validation(self):
        """Test content type validation for security."""
        # This test would be more relevant for web endpoints
        # For now, test that we handle various content types safely

        content_types = [
            "application/json",
            "text/html",
            "application/x-www-form-urlencoded",
            "multipart/form-data",
            "text/plain",
            "application/octet-stream",
        ]

        # All content types should be handled safely
        for content_type in content_types:
            # In our case, we don't directly handle HTTP content types
            # but we ensure our services can handle various input types
            assert isinstance(content_type, str)
            assert len(content_type) > 0
